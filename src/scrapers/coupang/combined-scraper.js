import HttpClient from '../../clients/http-client.js';
import CheckpointService from '../../services/checkpoint-service.js';
import CoupangStorageService from '../../services/coupang-storage-service.js';
import HttpRequestLoggerService from '../../services/http-request-logger-service.js';

class CoupangCombinedScraper {
  constructor(options = {}) {
    this.httpClient = new HttpClient({
      timeout: 30000,
      enableCookies: true,
      ...options,
    });
    this.httpLogger = new HttpRequestLoggerService();
    this.checkpointManager = new CheckpointService(options);
    this.storage = new CoupangStorageService(options);

    // Rate limiting: Î≤§ÎçîÎãπ 2Î≤à ÏöîÏ≤≠Ïù¥ÎØÄÎ°ú 200ms Í∞ÑÍ≤© (300 requests per minute)
    this.rateLimitDelay = 200; // milliseconds
    this.lastRequestTime = 0;

    // Î∞∞Ïπò ÏÑ§Ï†ï
    this.batchSize = options.batchSize || 100;
    this.autoSave = options.autoSave !== false; // Í∏∞Î≥∏Í∞í: true
  }

  async waitForRateLimit() {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;

    if (timeSinceLastRequest < this.rateLimitDelay) {
      const waitTime = this.rateLimitDelay - timeSinceLastRequest;
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }

    this.lastRequestTime = Date.now();
  }

  async getVendorInfo(storeId = 0, vendorId, urlName = '') {
    try {
      await this.waitForRateLimit();

      let url = `https://shop.coupang.com/api/v1/store/getStoreReview?storeId=${storeId}&vendorId=${vendorId}`;
      if (urlName) {
        url += `&urlName=${urlName}`;
      }

      const headers = {
        'User-Agent':
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        Accept: 'application/json, text/plain, */*',
        'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
        Referer: 'https://shop.coupang.com/',
        Origin: 'https://shop.coupang.com',
      };

      const response = await this.httpClient.get(url, {}, headers);

      // Rate limit Ï†ïÎ≥¥Îßå Ìïú Ï§ÑÎ°ú Ï∂úÎ†•
      const rateLimitInfo = {
        remaining: response.headers['x-ratelimit-remaining'] || 'N/A',
        requested: response.headers['x-ratelimit-requested-tokens'] || 'N/A',
        burst: response.headers['x-ratelimit-burst-capacity'] || 'N/A',
        replenish: response.headers['x-ratelimit-replenish-rate'] || 'N/A',
      };
      console.log(
        `üö¶ Rate Limit (${vendorId}): remaining=${rateLimitInfo.remaining}, requested=${rateLimitInfo.requested}, burst=${rateLimitInfo.burst}, replenish=${rateLimitInfo.replenish}`
      );

      return {
        success: true,
        storeId,
        vendorId,
        data: response.data,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.httpLogger.logError(error, `combined_vendor_error_${vendorId}`);

      return {
        success: false,
        storeId,
        vendorId,
        error: error.message,
        timestamp: new Date().toISOString(),
      };
    }
  }

  async getProductList(params) {
    try {
      await this.waitForRateLimit();

      const url = 'https://shop.coupang.com/api/v1/listing';

      const defaultParams = {
        storeId: params.storeId || 0,
        brandId: params.brandId || 0,
        vendorId: params.vendorId,
        sourceProductId: params.sourceProductId || 0,
        sourceVendorItemId: params.sourceVendorItemId || 0,
        source: params.source || 'brandstore_sdp_atf',
        enableAdultItemDisplay: params.enableAdultItemDisplay !== false,
        nextPageKey: params.nextPageKey || 0,
        filter: params.filter || 'SORT_KEY:',
      };

      const headers = {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36',
        'Content-Type': 'application/json',
        Accept: 'application/json, text/plain, */*',
        'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
        Referer: 'https://shop.coupang.com/',
        Origin: 'https://shop.coupang.com',
      };

      const response = await this.httpClient.post(url, defaultParams, headers);

      return {
        success: true,
        vendorId: params.vendorId,
        storeId: defaultParams.storeId,
        data: response.data,
        timestamp: new Date().toISOString(),
        requestParams: defaultParams,
      };
    } catch (error) {
      this.httpLogger.logError(
        error,
        `combined_product_error_${params.vendorId}`
      );

      return {
        success: false,
        vendorId: params.vendorId,
        storeId: params.storeId,
        error: error.message,
        timestamp: new Date().toISOString(),
        requestParams: params,
      };
    }
  }

  async getAllProducts(vendorId, storeId = 0, maxProducts = 5) {
    const allProducts = [];
    let nextPageKey = 0;
    let currentPage = 1;

    console.log(`${vendorId} ÏÉÅÌíà ÏàòÏßë ÏãúÏûë (ÏµúÎåÄ ${maxProducts}Í∞ú)`);

    while (allProducts.length < maxProducts) {
      console.log(
        `ÌéòÏù¥ÏßÄ ${currentPage} ÏàòÏßë Ï§ë... (nextPageKey: ${nextPageKey})`
      );

      const result = await this.getProductList({
        vendorId,
        storeId,
        nextPageKey,
      });

      if (!result.success) {
        console.log(`‚ùå ÌéòÏù¥ÏßÄ ${currentPage} ÏàòÏßë Ïã§Ìå®: ${result.error}`);
        break;
      }

      const products = result.data?.data?.products || [];
      if (products.length === 0) {
        console.log(`ÌéòÏù¥ÏßÄ ${currentPage}ÏóêÏÑú ÏÉÅÌíàÏù¥ ÏóÜÏùå. ÏàòÏßë Ï¢ÖÎ£å.`);
        break;
      }

      // ÌïÑÏöîÌïú ÎßåÌÅºÎßå Ï∂îÍ∞ÄÌïòÍ≥† ÏàòÏßëÏãúÍ∞Ñ Ï∂îÍ∞Ä
      const remainingNeeded = maxProducts - allProducts.length;
      const productsToAdd = products
        .slice(0, remainingNeeded)
        .map((product) => ({
          ...product,
          collectedAt: new Date().toISOString(),
        }));

      allProducts.push(...productsToAdd);
      console.log(
        `ÌéòÏù¥ÏßÄ ${currentPage}: ${productsToAdd.length}Í∞ú ÏÉÅÌíà ÏàòÏßë (Ï¥ù ${allProducts.length}Í∞ú)`
      );

      // Î™©Ìëú Í∞úÏàòÏóê ÎèÑÎã¨ÌïòÎ©¥ Ï¢ÖÎ£å
      if (allProducts.length >= maxProducts) {
        console.log(`Î™©Ìëú ÏÉÅÌíà Ïàò ${maxProducts}Í∞ú Îã¨ÏÑ±. ÏàòÏßë Ï¢ÖÎ£å.`);
        break;
      }

      // Îã§Ïùå ÌéòÏù¥ÏßÄÎäî nextPageKeyÎ•º 1Ïî© Ï¶ùÍ∞Ä
      nextPageKey++;
      currentPage++;
    }

    return allProducts;
  }

  async collectCombinedData(vendorIds, storeId = 0, maxProductsPerVendor = 5) {
    const results = [];

    console.log(`Ïø†Ìå° ÌÜµÌï© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏãúÏûë: ${vendorIds.length}Í∞ú Î≤§Îçî`);

    // ÌîÑÎ°ùÏãú ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî Î°úÍπÖ
    if (this.httpClient.proxies.length > 0) {
      console.log(`üì° ÌîÑÎ°ùÏãú ${this.httpClient.proxies.length}Í∞ú ÏÇ¨Ïö© Ï§ë`);
    }

    for (const vendorId of vendorIds) {
      console.log(`\n=== Ï≤òÎ¶¨ Ï§ë: vendorId ${vendorId} ===`);

      // 1. Î≤§Îçî Ï†ïÎ≥¥ ÏàòÏßë
      const vendorResult = await this.getVendorInfo(storeId, vendorId);

      if (!vendorResult.success) {
        console.log(`‚ùå Î≤§Îçî Ï†ïÎ≥¥ Ïã§Ìå®: ${vendorId} - ${vendorResult.error}`);
        continue;
      }

      // Î≤§Îçî Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (null nameÏù¥ÎÇò Îπà vendorId Ï†úÏô∏)
      const vendorData = vendorResult.data;
      if (
        !vendorData ||
        vendorData.name === null ||
        !vendorData.vendorId ||
        vendorData.vendorId.trim() === ''
      ) {
        console.log(`‚ùå Î≤§Îçî Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå: ${vendorId}`);
        continue;
      }

      console.log(`‚úÖ Î≤§Îçî Ï†ïÎ≥¥ ÏÑ±Í≥µ: ${vendorId} - ${vendorData.name}`);

      // 2. ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏßë
      const products = await this.getAllProducts(
        vendorId,
        storeId,
        maxProductsPerVendor
      );

      if (products.length === 0) {
        console.log(`‚ö†Ô∏è  ÏÉÅÌíà ÏóÜÏùå: ${vendorId} - Î≤§Îçî Ï†ïÎ≥¥Îßå Ï†ÄÏû•`);
        // ÏÉÅÌíàÏù¥ ÏóÜÏñ¥ÎèÑ Î≤§Îçî Ï†ïÎ≥¥Îäî Ï†ÄÏû• (ÏÉÅÌíà Ïª¨ÎüºÏùÄ ÎπàÍ∞í)
        results.push({
          ...vendorData,
          vendorId,
          storeId: vendorResult.storeId,
          ÏàòÏßëÏãúÍ∞Ñ: vendorResult.timestamp,
        });
      } else {
        console.log(`‚úÖ ÏÉÅÌíà ÏàòÏßë ÏÑ±Í≥µ: ${vendorId} - ${products.length}Í∞ú`);

        // 3. Î≤§Îçî Ï†ïÎ≥¥ÏôÄ ÏÉÅÌíà Ï†ïÎ≥¥ Í≤∞Ìï© (Ìïú ÌñâÏóê Î™®Îì† ÏÉÅÌíà Ï†ÄÏû•)
        const vendorWithProducts = {
          ...vendorData, // Î≤§Îçî Ï†ïÎ≥¥ Ï†ÑÏ≤¥
          vendorId,
          storeId: vendorResult.storeId,
          ÏàòÏßëÏãúÍ∞Ñ: vendorResult.timestamp,
        };

        // ÏÉÅÌíà Ï†ïÎ≥¥Î•º horizontalÌïòÍ≤å Ï∂îÍ∞Ä
        let productCollectedTime = '';
        products.forEach((product, index) => {
          const productNum = index + 1;
          vendorWithProducts[`ÏÉÅÌíàÎ™Ö${productNum}`] =
            product.imageAndTitleArea?.title || '';
          vendorWithProducts[`ÏÉÅÌíàÎßÅÌÅ¨${productNum}`] = product.link || '';
          vendorWithProducts[`ÏÉÅÌíàID${productNum}`] = product.productId || '';

          // Ï≤´ Î≤àÏß∏ ÏÉÅÌíàÏùò ÏàòÏßëÏãúÍ∞ÑÏùÑ Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©
          if (index === 0) {
            productCollectedTime = product.collectedAt || '';
          }
        });

        // ÏÉÅÌíàÏàòÏßëÏãúÍ∞ÑÏùÑ ÌïòÎÇòÎ°ú ÌÜµÏùº
        if (productCollectedTime) {
          vendorWithProducts['ÏÉÅÌíàÏàòÏßëÏãúÍ∞Ñ'] = productCollectedTime;
        }

        results.push(vendorWithProducts);
      }
    }

    console.log(`\nÌÜµÌï© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å: Ï¥ù ${results.length}Ìñâ`);

    // ÌîÑÎ°ùÏãú ÌÜµÍ≥Ñ Ï∂úÎ†•
    if (this.httpClient.proxies.length > 0) {
      this.httpClient.logProxyStats();
    }

    return results;
  }

  // ÏïàÏ†ÑÌïú ÎåÄÎüâ ÏàòÏßë (Î∞∞Ïπò + Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏)
  async collectCombinedSafe(
    vendorIds,
    storeId = 0,
    maxProductsPerVendor = 5,
    options = {}
  ) {
    const sessionId =
      options.resumeSessionId || this.checkpointManager.generateSessionId();
    let checkpoint;

    try {
      // Í∏∞Ï°¥ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Î°úÎìú ÎòêÎäî ÏÉàÎ°ú ÏÉùÏÑ±
      if (options.resumeSessionId) {
        checkpoint = await this.checkpointManager.loadCheckpoint(sessionId);
        if (!checkpoint) {
          throw new Error(`Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${sessionId}`);
        }
        console.log(`üîÑ ÏÑ∏ÏÖò Ïû¨Í∞ú: ${sessionId}`);
      } else {
        checkpoint = this.checkpointManager.createCheckpoint(
          sessionId,
          vendorIds,
          {
            batchSize: this.batchSize,
            maxProductsPerVendor,
            storeId,
            ...options,
          }
        );
        await this.checkpointManager.saveCheckpoint(sessionId, checkpoint);
        console.log(`üöÄ ÏÉà ÏÑ∏ÏÖò ÏãúÏûë: ${sessionId}`);
      }

      console.log(
        `Ïø†Ìå° ÏïàÏ†Ñ ÏàòÏßë ÏãúÏûë: ${vendorIds.length}Í∞ú Î≤§Îçî (Î∞∞Ïπò ÌÅ¨Í∏∞: ${this.batchSize})`
      );

      // Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Î≤§ÎçîÎì§ Ïä§ÌÇµ
      const remainingVendors = vendorIds.slice(checkpoint.currentIndex);
      let currentBatch = [];
      let batchIndex = checkpoint.currentBatch;
      let processedInSession = 0;
      let currentPosition = checkpoint.currentIndex; // Ï†ÑÏ≤¥ ÏßÑÌñâÎ•†Ïö©

      for (let i = 0; i < remainingVendors.length; i++) {
        const vendorId = remainingVendors[i];
        currentPosition++; // Í∞Å Î≤§Îçî Ï≤òÎ¶¨ ÏãúÏûëÌï† Îïå Ï¶ùÍ∞Ä

        console.log(
          `\n=== [${i + 1}/${remainingVendors.length}] Ï≤òÎ¶¨ Ï§ë: ${vendorId} ===`
        );

        try {
          // 1. Î≤§Îçî Ï†ïÎ≥¥ ÏàòÏßë
          const vendorResult = await this.getVendorInfo(storeId, vendorId);

          if (!vendorResult.success) {
            console.log(
              `‚ùå Î≤§Îçî Ï†ïÎ≥¥ Ïã§Ìå®: ${vendorId} - ${vendorResult.error}`
            );
            checkpoint.processedVendors.push({
              vendorId,
              status: 'vendor_failed',
              error: vendorResult.error,
            });
            continue;
          }

          // Î≤§Îçî Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          const vendorData = vendorResult.data;
          if (
            !vendorData ||
            vendorData.name === null ||
            !vendorData.vendorId ||
            vendorData.vendorId.trim() === ''
          ) {
            console.log(`‚ùå Î≤§Îçî Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå: ${vendorId}`);
            checkpoint.processedVendors.push({
              vendorId,
              status: 'invalid_data',
            });
            continue;
          }

          console.log(`‚úÖ Î≤§Îçî Ï†ïÎ≥¥ ÏÑ±Í≥µ: ${vendorId} - ${vendorData.name}`);

          // 2. ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏßë
          const products = await this.getAllProducts(
            vendorId,
            storeId,
            maxProductsPerVendor
          );

          // 3. Îç∞Ïù¥ÌÑ∞ Í≤∞Ìï©
          const vendorWithProducts = {
            ...vendorData,
            vendorId,
            storeId: vendorResult.storeId,
            ÏàòÏßëÏãúÍ∞Ñ: vendorResult.timestamp,
          };

          if (products.length === 0) {
            console.log(`‚ö†Ô∏è  ÏÉÅÌíà ÏóÜÏùå: ${vendorId} - Î≤§Îçî Ï†ïÎ≥¥Îßå Ï†ÄÏû•`);
            // ÏÉÅÌíàÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Îπà ÏÉÅÌíà ÌïÑÎìúÎì§ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
          } else {
            console.log(
              `‚úÖ ÏÉÅÌíà ÏàòÏßë ÏÑ±Í≥µ: ${vendorId} - ${products.length}Í∞ú`
            );
            // ÏÉÅÌíà Ï†ïÎ≥¥Î•º horizontalÌïòÍ≤å Ï∂îÍ∞Ä
            let productCollectedTime = '';
            products.forEach((product, index) => {
              const productNum = index + 1;
              vendorWithProducts[`ÏÉÅÌíàÎ™Ö${productNum}`] =
                product.imageAndTitleArea?.title || '';
              vendorWithProducts[`ÏÉÅÌíàÎßÅÌÅ¨${productNum}`] = product.link || '';
              vendorWithProducts[`ÏÉÅÌíàID${productNum}`] =
                product.productId || '';

              // Ï≤´ Î≤àÏß∏ ÏÉÅÌíàÏùò ÏàòÏßëÏãúÍ∞ÑÏùÑ Í≥µÌÜµÏúºÎ°ú ÏÇ¨Ïö©
              if (index === 0) {
                productCollectedTime = product.collectedAt || '';
              }
            });

            // ÏÉÅÌíàÏàòÏßëÏãúÍ∞ÑÏùÑ ÌïòÎÇòÎ°ú ÌÜµÏùº
            if (productCollectedTime) {
              vendorWithProducts['ÏÉÅÌíàÏàòÏßëÏãúÍ∞Ñ'] = productCollectedTime;
            }
          }

          currentBatch.push(vendorWithProducts);

          checkpoint.processedVendors.push({
            vendorId,
            status: 'success',
            productCount: products.length,
          });
          processedInSession++;
        } catch (error) {
          console.error(`üí• Î≤§Îçî Ï≤òÎ¶¨ Ïò§Î•ò (${vendorId}):`, error.message);
          checkpoint.processedVendors.push({
            vendorId,
            status: 'error',
            error: error.message,
          });
        }

        // Î∞∞Ïπò Ï†ÄÏû• (Î∞∞Ïπò ÌÅ¨Í∏∞ ÎèÑÎã¨Ïãú)
        if (currentBatch.length >= this.batchSize) {
          if (currentBatch.length > 0 && this.autoSave) {
            await this.storage.saveIncrementalBatch(
              currentBatch,
              batchIndex,
              sessionId
            );
            console.log(
              `üì¶ Î∞∞Ïπò ${batchIndex} Ï†ÄÏû• ÏôÑÎ£å: ${currentBatch.length}Ìñâ`
            );
            currentBatch = [];
            batchIndex++;
          }

          // Î∞∞Ïπò Ï†ÄÏû• ÏãúÏóêÎßå Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
          checkpoint.currentIndex = currentPosition;
          checkpoint.currentBatch = batchIndex;
          this.checkpointManager.updateProgress(
            checkpoint,
            currentPosition,
            batchIndex
          );
          await this.checkpointManager.saveCheckpoint(sessionId, checkpoint);

          const progress = Math.floor(
            (currentPosition / vendorIds.length) * 100
          );
          console.log(
            `üíæ ÏßÑÌñâÎ•†: ${currentPosition}/${vendorIds.length} (${progress}%)`
          );
        }
      }

      // ÎßàÏßÄÎßâ Î∞∞Ïπò Ï†ÄÏû• (ÎÇ®ÏùÄ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥)
      if (currentBatch.length > 0 && this.autoSave) {
        await this.storage.saveIncrementalBatch(
          currentBatch,
          batchIndex,
          sessionId
        );
        console.log(
          `üì¶ ÎßàÏßÄÎßâ Î∞∞Ïπò ${batchIndex} Ï†ÄÏû• ÏôÑÎ£å: ${currentBatch.length}Ìñâ`
        );
        batchIndex++;
      }

      // ÏôÑÎ£å Ï≤òÎ¶¨ - ÏµúÏ¢Ö ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
      checkpoint.currentIndex = currentPosition;
      checkpoint.currentBatch = batchIndex;
      checkpoint.status = 'completed';
      checkpoint.endTime = new Date().toISOString();
      this.checkpointManager.updateProgress(
        checkpoint,
        currentPosition,
        batchIndex
      );
      await this.checkpointManager.saveCheckpoint(sessionId, checkpoint);

      const finalProgress = Math.floor(
        (currentPosition / vendorIds.length) * 100
      );
      console.log(
        `üíæ ÏµúÏ¢Ö ÏßÑÌñâÎ•†: ${currentPosition}/${vendorIds.length} (${finalProgress}%)`
      );

      console.log(`\n‚úÖ ÏïàÏ†Ñ ÏàòÏßë ÏôÑÎ£å!`);
      console.log(`   ÏÑ∏ÏÖò ID: ${sessionId}`);
      console.log(`   Ï≤òÎ¶¨Îêú Î≤§Îçî: ${processedInSession}Í∞ú`);
      console.log(`   Ï†ÄÏû•Îêú Î∞∞Ïπò: ${batchIndex}Í∞ú`);

      // ÌîÑÎ°ùÏãú ÌÜµÍ≥Ñ Ï∂úÎ†•
      if (this.httpClient.proxies.length > 0) {
        this.httpClient.logProxyStats();
      }

      return {
        sessionId,
        checkpoint,
        batchCount: batchIndex,
        processedVendors: processedInSession,
      };
    } catch (error) {
      console.error('üí• ÏïàÏ†Ñ ÏàòÏßë Ï§ë ÏπòÎ™ÖÏ†Å Ïò§Î•ò:', error.message);

      // Ïò§Î•ò Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•
      if (checkpoint) {
        checkpoint.status = 'error';
        checkpoint.error = error.message;
        checkpoint.errorTime = new Date().toISOString();
        await this.checkpointManager.saveCheckpoint(sessionId, checkpoint);
      }

      throw error;
    }
  }

  // ÏÑ∏ÏÖò Ïû¨Í∞ú
  async resumeSession(sessionId, options = {}) {
    console.log(`üîÑ ÏÑ∏ÏÖò Ïû¨Í∞ú: ${sessionId}`);
    return await this.collectCombinedSafe([], 0, 5, {
      ...options,
      resumeSessionId: sessionId,
    });
  }

  // ÏÑ∏ÏÖò ÏôÑÎ£å (Î∞∞Ïπò Î≥ëÌï©)
  async completeSession(sessionId, options = {}) {
    console.log(`üîó ÏÑ∏ÏÖò ÏôÑÎ£å Ï≤òÎ¶¨: ${sessionId}`);

    try {
      // Î∞∞Ïπò Î≥ëÌï©
      const mergedFile = await this.storage.mergeBatches(
        sessionId,
        options.finalFilename
      );

      // Î∞∞Ïπò ÌååÏùº Ï†ïÎ¶¨ (ÏòµÏÖò)
      if (options.cleanupBatches !== false) {
        // await this.storage.cleanupBatches(sessionId, false);
      }

      // Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ïÎ¶¨ (ÏòµÏÖò)
      if (options.cleanupCheckpoint !== false) {
        // await this.checkpointManager.deleteCheckpoint(sessionId);
      }

      console.log(`‚úÖ ÏÑ∏ÏÖò ÏôÑÎ£å: ${mergedFile}`);
      return mergedFile;
    } catch (error) {
      console.error('ÏÑ∏ÏÖò ÏôÑÎ£å Ï≤òÎ¶¨ Ïã§Ìå®:', error.message);
      throw error;
    }
  }

  async collectCombinedByRange(
    startVendorId = 1,
    endVendorId = 100,
    storeId = 0,
    maxProductsPerVendor = 5
  ) {
    const vendorIds = [];

    for (
      let vendorIdNum = startVendorId;
      vendorIdNum <= endVendorId;
      vendorIdNum++
    ) {
      const vendorId = `A${String(vendorIdNum).padStart(8, '0')}`;
      vendorIds.push(vendorId);
    }

    return await this.collectCombinedData(
      vendorIds,
      storeId,
      maxProductsPerVendor
    );
  }

  // ÏïàÏ†ÑÌïú Î≤îÏúÑ ÏàòÏßë
  async collectCombinedByRangeSafe(
    startVendorId = 1,
    endVendorId = 100,
    storeId = 0,
    maxProductsPerVendor = 5,
    options = {}
  ) {
    const vendorIds = [];

    for (
      let vendorIdNum = startVendorId;
      vendorIdNum <= endVendorId;
      vendorIdNum++
    ) {
      const vendorId = `A${String(vendorIdNum).padStart(8, '0')}`;
      vendorIds.push(vendorId);
    }

    return await this.collectCombinedSafe(
      vendorIds,
      storeId,
      maxProductsPerVendor,
      options
    );
  }
}

export default CoupangCombinedScraper;
